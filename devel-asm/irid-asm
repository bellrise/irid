#!/usr/bin/python3
# Irid assembler

import argparse
import struct


def parse_value(src: str) -> int:
    if src[0] == "'" and len(src) >= 3:
        if src[1] == '\\':
            # special char
            special_chars = {
                'n': '\n',
                'r': '\r',
                't': '\t',
                'b': '\b'
            }

            return ord(special_chars.get(src[2], '?'))
        return ord(src[1])

    if src.startswith('0x'):
        return int(src, 16)
    else:
        return int(src)

class Line:
    """Represents a single line. """

    raw: str            # the original line
    parts: list[str]    # the split parts

    def __init__(self, original_line: str):
        self.raw = original_line
        self.parts = self._split_into_parts(original_line)

    def _split_into_parts(self, string: str) -> list[str]:
        parts = []
        buf = ''
        in_string = None

        for c in string:
            if c == '"' and in_string == '"':
                in_string = None
            elif c == '"' and not in_string:
                in_string = '"'
            elif c == "'" and in_string == "'":
                in_string = None
            elif c == "'" and not in_string:
                in_string = "'"

            if not in_string and c.isspace() and len(buf):
                parts.append(buf)
                buf = ''
                continue

            buf += c

        parts.append(buf)

        return [x.strip() for x in parts if x.strip()]

    def startswith(self, string: str):
        return self.raw.startswith(string)

    def endswith(self, string: str):
        return self.raw.endswith(string)

    def substr(self, start: int, stop: int):
        return self.raw[start:stop]

    def part(self, index: int):
        return self.parts[index]

    def int_value(self, index: int):
        src = self.part(index)
        if src[0] == "'" and len(src) >= 3:
            if src[1] == '\\':
                # special char
                special_chars = {
                    'n': '\n',
                    'r': '\r',
                    't': '\t',
                    'b': '\b'
                }

                return ord(special_chars.get(src[2], '?'))

            return ord(src[1])
        if src.startswith('0x'):
            return int(src, 16)
        else:
            return int(src)

    def join_parts(self, start: int, stop: int):
        return ' '.join(self.parts[start:stop])


class Assembler:
    """The whole thing. """

    source_path: str    # source file path
    source: list[str]   # source file as a list of lines
    output: bytearray   # program in binary
    pos: int            # current position in binary file
    labels: dict        # list of labels
    link_points: list   # list of locations to link
    last_label: str     # last major label
    macros: dict        # list of macros

    INVALID_REG = -1

    def __init__(self, input_path: str):
        with open(input_path) as f:
            self.source = f.readlines()
        self.source_path = input_path
        self.output = bytearray()
        self.pos = 0
        self.labels = {}
        self.macros = {}
        self.link_points = []

    def assemble(self):
        # Assemble the whole file.
        self._clean_up()

        for index, raw_line in enumerate(self.source):
            if not raw_line:
                continue

            line = Line(raw_line)

            for i, part in enumerate(line.parts):
                if part in self.macros:
                    line.parts[i] = self.macros[part]

            if line.startswith('\t') or line.startswith(' '):
                self._add_instruction(line, index)
                pass
            elif line.startswith('.'):
                self._parse_directive(line, index, raw_line)
            elif line.endswith(':'):
                self._add_label(line, index)
            else:
                self._die(index, 'unknown line')

        filled_link_points = []
        for link_point in self.link_points:
            if link_point['symbol'] not in self.labels:
                self._die(link_point['index'],
                          f'missing label declaration for `{link_point["symbol"]}`')

            self._insert_bytes(link_point['at'],
                               self._split_imm16(self.labels[link_point['symbol']]))
            filled_link_points.append(link_point)

        for link_point in self.link_points:
            if link_point not in filled_link_points:
                self._die(link_point['index'], f'`{link_point["symbol"]}` was not linked')


    def dump_program(self, output_path: str):
        with open(output_path, 'wb') as f:
            f.write(self.output)

    def dump_symbols(self):
        print(f'Symbols in {self.source_path}:')
        syms = {}
        for k, v in self.labels.items():
            syms[v] = k

        for addr in sorted(syms.keys()):
            print(f'  {addr:04x} {syms[addr]}')

    def _clean_up(self):
        # Remove comments & newlines.
        for index, line in enumerate(self.source):
            # Remove comments starting from the middle of the line.
            in_string = None
            comment_start = None

            for i, char in enumerate(line):
                if char == '"' and in_string == '"':
                    in_string = None
                if char == '"' and not in_string:
                    in_string = '"'
                if char == "'" and in_string == "'":
                    in_string = None
                if char == "'" and not in_string:
                    in_string = "'"

                if not in_string and char == ';':
                    comment_start = i
                    break

            if comment_start:
                line = line[:comment_start]
            self.source[index] = line.rstrip()
            if line.strip().startswith(';') or not line.strip():
                self.source[index] = None

    def _parse_string(self, source: str) -> bytes:
        special_chars = {
            'n': '\n',
            'r': '\r',
            't': '\t',
            'b': '\b'
        }

        s = source.strip('"')
        for char, val in special_chars.items():
            s = s.replace('\\' + char, val)

        return bytes(s, 'ascii')

    def _parse_directive(self, line: Line, index: int, raw_line: str):
        dir = line.part(0)[1:]

        if dir == 'org':
            # Move to another origin point
            self.pos = parse_value(line.part(1))

        elif dir == 'string':
            # Place a string in memory
            data = line.part(1)
            s = self._parse_string(data) + b'\0'
            self._insert_bytes(self.pos, s, auto_offset=False)
            self.pos += len(s)

        elif dir == 'res':
            # Reserve n bytes
            b = b'\0' * parse_value(line.part(1))
            self._insert_bytes(self.pos, b, auto_offset=True)

        elif dir == 'byte':
            # Place a byte (u8)
            initial_value = parse_value(line.part(1))
            self._insert_bytes(self.pos, [initial_value], auto_offset=True)

        elif dir == 'word':
            # Place a word (u16)
            initial_value = parse_value(line.part(1))
            bytes_value = self._split_imm16(initial_value)
            self._insert_bytes(self.pos, bytes_value, auto_offset=True)

        elif dir == 'macro':
            parts = raw_line.split(maxsplit=2)
            macro = parts[1]
            if len(parts) > 2:
                value = parts[2]
            else:
                value = ''

            self.macros[macro] = value

        else:
            self._die(index, f'unknown directive `{dir}`')

    def _add_label(self, line: Line, index: int):
        label = line.part(0).strip(':')
        if not label.startswith('@'):
            # Regular label
            self.labels[label] = self.pos
            self.last_label = label
        else:
            # Local label
            self.labels[self.last_label + label] = self.pos

    def _insert_bytes(self, pos: int, data, auto_offset=True):
        if len(self.output) == pos:
            self.output.extend(data)
        elif len(self.output) < pos:
            self.output.extend([0x00] * (pos - len(self.output)))
            self.output.extend(data)
        else:
            for i in range(len(data)):
                self.output[pos + i] = data[i]
        if auto_offset:
            self.pos += len(data)

    def _add_instruction(self, line: Line, index: int):
        # Add instruction to binary output

        # Align pos to a 4 byte boundry.
        if self.pos % 4:
            self.pos += 4 - (self.pos % 4)

        title = line.part(0)
        method = getattr(self, f'_ins_{title}', None)
        if method:
            ins = method(line, index)
        else:
            self._die(index, 'unknown instruction')

        # Place the instruction in the binary.
        self._insert_bytes(self.pos, ins)

    def _is_symbol(self, string: str) -> bool:
        return string[0].isalpha() or string[0] == '@'

    def _die(self, index: int, *errmsg):
        errmsg = ' '.join([str(x) for x in errmsg])

        offset = len(self.source[index]) - len(self.source[index].lstrip())
        offset = ' ' * offset

        print(f'irid-asm: \033[31merror\033[0m in {self.source_path} on line {index}\n')
        print(f'\033[90m{index: 3} |\033[0m', self.source[index])
        print(f'      \033[31m{offset}^')
        print(f'      {offset}{errmsg}\033[0m\n')
        exit(1)

    def _register_id(self, name: str) -> int:
        register_map = {
            'r*': 0x00,
            'h*': 0x10,
            'l*': 0x20,
            'ip': 0x70,
            'sp': 0x71,
            'bp': 0x72
        }

        if name in register_map:
            return register_map[name]
        for k, v in register_map.items():
            if '*' not in k:
                continue
            if name[0] == k[0]:
                return v + int(name[1:])
        return self.INVALID_REG

    def _is_wide_register(self, name: str) -> bool:
        return name in ['ip', 'sp', 'bp'] or name.startswith('r')

    def _is_half_register(self, name: str) -> bool:
        return name.startswith('h') or name.startswith('l')

    def _split_imm16(self, imm: int) -> list:
        return [imm - ((imm // 256) * 256), imm // 256]

    def _parse_symbol(self, sym: str) -> str:
        if sym.startswith('@'):
            sym = self.last_label + sym
        return sym

    def _make_r816_instruction(self, line: Line, index: int,
                               r_ins: int, r_8: int, r_16: int) -> list:
        dest = line.part(1).strip(',')
        src = line.part(2)

        dest_reg = self._register_id(dest)

        # First argument is always a register
        if dest_reg == self.INVALID_REG:
            self._die(index, f'unknown register `{dest}`')

        # If the second argument is a symbol, it may a register or label.
        if self._is_symbol(src):
            # Check for a register
            src_reg = self._register_id(src)
            if src_reg != self.INVALID_REG:
                # ins rx, rx
                return [r_ins, dest_reg, src_reg, 0x00]

            # If not a register, than a symbol.
            self.link_points.append({
                'symbol': self._parse_symbol(src),
                'at': self.pos + 2,
                'index': index
            })
            # ins rx, imm16
            return [r_16, dest_reg, 0x00, 0x00]

        # Immediate value
        imm = parse_value(src)
        if imm >= 256:
            imm = self._split_imm16(imm)
            # ins rx, imm16
            return [r_16, dest_reg, imm[0], imm[1]]

        # ins rx, imm8
        return [r_8, dest_reg, imm, 0x00]

    def _ins_mov(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x14, 0x15, 0x16)

    def _ins_load(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x17, 0x23, 0x23)

    def _ins_store(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x18, 0x24, 0x24)

    def _ins_cmp(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x1a, 0x1b, 0x1c)

    def _ins_cmg(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x1d, 0x1e, 0x1f)

    def _ins_cml(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x20, 0x21, 0x22)

    def _ins_cpucall(self, line: Line, index: int) -> list:
        return [0x01, 0x00, 0x00, 0x00]

    def _ins_rti(self, line: Line, index: int) -> list:
        return [0x02, 0x00, 0x00, 0x00]

    def _ins_sti(self, line: Line, index: int) -> list:
        return [0x03, 0x00, 0x00, 0x00]

    def _ins_dsi(self, line: Line, index: int) -> list:
        return [0x04, 0x00, 0x00, 0x00]

    def _ins_call(self, line: Line, index: int) -> list:
        arg = line.part(1)
        r0 = self._register_id(arg)
        if r0 != self.INVALID_REG:
            # Call address from register
            return [0x34, r0, 0x00, 0x00]

        if not self._is_symbol(arg):
            # A immediate address
            addr = self._split_imm16(line.int_value(1))
            return [0x33, addr[0], addr[1], 0x00]

        # Call a symbol (link after)
        self.link_points.append({
            'symbol': line.part(1),
            'at': self.pos + 1,
            'index': index
        })
        return [0x33, 0x00, 0x00, 0x00]

    def _ins_push(self, line: Line, index: int) -> list:
        if line.part(1)[0].isalpha():
            # push register
            rid = self._register_id(line.part(1))
            if rid == self.INVALID_REG:
                self._die(index, f'unknown register `{line.part(1)}`')
            return [0x10, rid, 0x00, 0x00]

        v = line.int_value(1)
        if v >= 256:
            # push16
            v = self._split_imm16(v)
            return [0x12, v[0], v[1], 0x00]

        # push8
        return [0x11, v, 0x00, 0x00]

    def _ins_add(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x36, 0x37, 0x38)

    def _ins_sub(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x39, 0x3a, 0x3b)

    def _ins_and(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x3c, 0x3d, 0x3e)

    def _ins_or(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x3f, 0x40, 0x41)

    def _ins_not(self, line: Line, index: int) -> list:
        dest = line.part(1)
        dest_reg = self._register_id(dest)
        if dest_reg == self.INVALID_REG:
            self._die(index, f'unknown register `{dest}`')
        return [0x42, dest_reg, 0x00, 0x00]

    def _ins_shr(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x43, 0x44, 0x44)

    def _ins_shl(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x45, 0x46, 0x46)

    def _ins_mul(self, line: Line, index: int) -> list:
        return self._make_r816_instruction(line, index, 0x47, 0x48, 0x49)

    def _ins_pop(self, line: Line, index: int) -> list:
        rid = self._register_id(line.part(1))
        if rid == self.INVALID_REG:
            self._die(index, f'unknown register `{line.part(1)}`')
        return [0x13, rid, 0x00, 0x00]

    def _ins_jmp(self, line: Line, index: int) -> list:
        self.link_points.append({
            'symbol': self._parse_symbol(line.part(1)),
            'at': self.pos + 1,
            'index': index
        })

        return [0x30, 0x00, 0x00, 0x00]

    def _ins_jnz(self, line: Line, index: int) -> list:
        r0_src = line.part(1).strip(',')
        r0 = self._register_id(r0_src)
        if r0 == self.INVALID_REG:
            self._die(index, f'unknown register `{r0_src}`')

        self.link_points.append({
            'symbol': self._parse_symbol(line.part(2)),
            'at': self.pos + 2,
            'index': index
        })

        return [0x31, r0, 0x00, 0x00]

    def _ins_jeq(self, line: Line, index: int) -> list:
        self.link_points.append({
            'symbol': self._parse_symbol(line.part(1)),
            'at': self.pos + 1,
            'index': index
        })

        return [0x32, 0x00, 0x00, 0x00]


    def _ins_ret(self, line: Line, index: int) -> list:
        return [0x35, 0x00, 0x00, 0x00]


def main():
    parser = argparse.ArgumentParser(
        description='Convert Irid assembly into a binary format.')
    parser.add_argument('input', help='input file')
    parser.add_argument('-o', '--output', required=False)
    parser.add_argument('-s', '--sym', action='store_true', required=False)

    args = parser.parse_args()
    if not args.output:
        args.output = 'out.bin'

    asm = Assembler(args.input)
    asm.assemble()
    asm.dump_program(args.output)

    if args.sym:
        asm.dump_symbols()


main()
