#!/usr/bin/python3
# Irid assembler

import argparse
import struct


class Assembler:
    """The whole thing. """

    source_path: str    # source file path
    source: list[str]   # source file as a list of lines
    output: bytearray   # program in binary
    pos: int            # current position in binary file
    labels: dict        # list of labels

    def __init__(self, input_path: str):
        with open(input_path) as f:
            self.source = f.readlines()
        self.source_path = input_path
        self.output = bytearray()
        self.pos = 0
        self.labels = {}

    def assemble(self):
        # Assemble the whole file.
        self._clean_up()

        for index, line in enumerate(self.source):
            if not line:
                continue

            if line.startswith('\t') or line.startswith(' '):
                self._add_instruction(line, index)
                pass
            elif line.startswith('.'):
                self._parse_directive(line, index)
            elif line.endswith(':'):
                self._add_label(line, index)
            else:
                self._die('unknown line')

    def dump_program(self, output_path: str):
        with open(output_path, 'wb') as f:
            f.write(self.output)

    def _clean_up(self):
        # Remove comments & newlines.
        for index, line in enumerate(self.source):
            self.source[index] = line.rstrip()
            if line.strip().startswith(';') or not line.strip():
                self.source[index] = None

    def _parse_directive(self, line: str, index: int):
        line = line[1:]
        dir = line.split()[0]

        if dir == 'org':
            # TODO: make this support decimal
            self.pos = int(line.split()[1], 16)
        elif dir == 'string':
            data = line[6:].strip().strip('"')
            self._insert_bytes(self.pos, bytes(data, 'ascii') + b'\0')
        else:
            self._die(index, f'unknown directive `{dir}`')

    def _add_label(self, line: str, index: int):
        line = line[:-1]
        self.labels[line] = self.pos

    def _insert_bytes(self, pos: int, data):
        if len(self.output) == pos:
            self.output.extend(data)
            self.pos += 4
        elif len(self.output) < pos:
            self.output.extend([0x00] * (pos - len(self.output)))
            self.output.extend(data)
            self.pos += 4
        else:
            for i in range(len(data)):
                self.output[pos + i] = data[i]

    def _add_instruction(self, line: str, index: int):
        # Add instruction to binary output
        # TODO: actually parse the instruction

        title = line.strip().split()[0]
        method = getattr(self, f'_ins_{title}')
        if method:
            ins = method(line, index)
        else:
            self._die('unknown instruction')

        # Place the instruction in the binary
        self._insert_bytes(self.pos, ins)

    def _die(self, index: int, *errmsg):
        errmsg = ' '.join([str(x) for x in errmsg])
        print(f'irid-asm: \033[31merror\033[0m in {self.source_path} on line {index}\n')
        print(f'\033[90m{index: 3} |\033[0m', self.source[index])
        print('      \033[31m^')
        print(f'      {errmsg}\033[0m\n')
        exit(1)

    def _register_id(self, name: str) -> int:
        register_map = {
            'r*': 0x00,
            'h*': 0x10,
            'l*': 0x20,
            'ip': 0x70,
            'sp': 0x71,
            'bp': 0x72
        }

        if name in register_map:
            return register_map[name]
        for k, v in register_map.items():
            if '*' not in k:
                continue
            if name[0] == k[0]:
                return v + int(name[1:])

    def _ins_mov(self, line: str, index: int) -> list:
        line = line.strip()[3:].strip()
        reg, value = [x.strip() for x in line.split(',')]

        # TODO: support mov & mov8

        value = int(value, 16)
        data = struct.pack('<H', value)

        return [0x16, self._register_id(reg), data[0], data[1]]

    def _ins_cpucall(self, line: str, index: int) -> list:
        return [0x01, 0x00, 0x00, 0x00]


def main():
    parser = argparse.ArgumentParser(
        description='Convert Irid assembly into a binary format.')
    parser.add_argument('input', help='input file')
    parser.add_argument('-o', '--output', required=False)

    args = parser.parse_args()
    if not args.output:
        args.output = 'out.bin'

    asm = Assembler(args.input)
    asm.assemble()
    asm.dump_program(args.output)


main()
